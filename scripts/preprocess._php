<?php

/**
 * @file
 * Preprocesses AsciiDoc text.
 *
 * Use with care -- things in the output directory will be overwritten!
 *
 * Command-line arguments: Source directory, output directory, steps
 * where steps is a character string like fi
 *
 * Depending on the characters in steps, the following processing can happen,
 * after which the resulting files are written to the output directory with
 * the same names. Possible processing steps -- if steps contains:
 * - f: Adds filenames. Specifically, adds:
 *   @code
 *   pass:[<remark>Source file: (filename)</remark>]
 *   @endcode
 *   after each 2nd-level and 3rd-level header found in the file.
 */

if (count($argv) < 4) {
  exit("Usage: php (scriptname) source output steps, where steps is some combination of characters fi");
}

$source = $argv[1];
$output = $argv[2];
$steps = $argv[3];

if (!is_dir($source) || !is_dir($output)) {
  exit("Source or output directories are missing");
}
if ($source == $output) {
  exit("Source and output directories are the same");
}

// Find all *.txt files in the source directory and process them.
if ($dh = opendir($source)) {
  while (($file = readdir($dh)) !== FALSE) {
    if (preg_match('|^[a-zA-Z_.\-]+\.txt$|', $file)) {
      $text = file_get_contents($source . '/' . $file);
      if ($text && strpos($steps, 'f') !== FALSE) {
        $text = add_filenames($text, $file);
      }
      if ($text) {
        $count = file_put_contents($output . '/' . $file, $text);
      }
      if (!$text || !$count) {
        exit("Could not write to $file");
      }
    }
  }
  closedir($dh);
}

/**
 * Adds filenames to the text of a file.
 *
 * @param string $text
 *   Text of the file.
 * @param string $filename
 *   Name of the file being processed, without the directory.
 * @param int[] depths
 *   (optional) Header depths to add file name to.
 *
 * @return string
 *   Processed text of the file.
 */
function add_filenames($text, $filename, $depths = array(2,3)) {
  $addition = "pass:[<remark>Source file: $filename</remark>]\n";

  // Make a regular expression to match level-N headers, which are '==' or
  // '===' or whatever at the start of a line.
  $match = array();
  foreach ($depths as $depth) {
    $match[] = preg_quote(str_repeat('=', $depth));
  }
  $match = array_filter($match);
  if (!count($match)) {
    return FALSE;
  }
  $match = '/^(' . implode('|', $match) . ')[^\=].*$/m';

  // Split the text at code block indicator lines: ----.
  // Only process the odd results, which will skip processing the code blocks.
  $codes = preg_split('/^----$/m', $text);
  for ($i = 0; $i < count($codes); $i += 2) {
    $codes[$i] = preg_replace($match, '$0' . "\n" . $addition, $codes[$i]);
  }
  $text = implode("----\n", $codes);
  return $text;
}
